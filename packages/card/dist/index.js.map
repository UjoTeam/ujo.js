{"version":3,"sources":["../src/index.js"],"names":["HASH_PREAMBLE","DEPOSIT_MINIMUM_WEI","ethers","utils","parseEther","HUB_EXCHANGE_CEILING","opts","headers","Authorization","withCredentials","Card","cb","address","web3","connext","tokenAddress","tokenContract","channelState","connextState","stateUpdateCallback","exchangeRate","hubUrl","rpcProvider","mnemonic","localStorage","getItem","delegateSigner","getAddressString","setWeb3","setConnext","setTokenContract","authorizeHandler","pollConnextState","poller","rpcUrl","providerOpts","ProviderOptions","approving","provider","customWeb3","Web3","options","user","eth","Contract","tokenAbi","e","console","log","that","on","state","persistent","channel","balance","balanceTokenUser","substr","cents","substring","length","runtime","rates","USD","start","autoDeposit","autoSwap","setInterval","getBalance","tokenBalance","methods","balanceOf","call","net","getId","message","warn","bigNumberify","lte","canDeposit","actualDeposit","amountWei","sub","toString","amountToken","deposit","depositRes","canExchange","weiBalance","balanceWeiUser","gt","exchange","axios","post","challengeRes","data","sha3","nonce","hash","personal","sign","signature","origin","authRes","token","document","cookie","get","res","value","payment","meta","purchaseId","payments","type","recipient","emptyAddress","secret","generateSecret","amount","Math","pow","paymentHandler","recipientAddress","JSON","stringify","paymentAmount","BN","isZero","isAddress","addressError","balanceError","buy","paymentRes","redeem","updated"],"mappings":"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","sourcesContent":["import 'babel-polyfill';\nimport { getConnextClient } from 'connext/dist/Connext';\nimport axios from 'axios';\nimport Web3 from 'web3';\nimport { ethers } from 'ethers';\nimport { emptyAddress } from 'connext/dist/Utils';\nimport { convertPayment } from 'connext/dist/types';\nimport BN from 'bn.js';\n\nimport ProviderOptions from './utils/ProviderOptions';\nimport clientProvider from './utils/web3/clientProvider';\nimport { getDollarSubstring } from './utils/getDollarSubstring';\nimport createWallet from './walletGen';\nimport tokenAbi from './abi/humanToken.json';\n\n// set constants\nconst HASH_PREAMBLE = 'SpankWallet authentication message:';\nconst DEPOSIT_MINIMUM_WEI = ethers.utils.parseEther('0.03'); // 30 FIN\nconst HUB_EXCHANGE_CEILING = ethers.utils.parseEther('69'); // 69 TST\nconst opts = {\n  headers: {\n    'Content-Type': 'application/json; charset=utf-8',\n    Authorization: 'Bearer foo',\n  },\n  withCredentials: true,\n};\n\n// define class\nclass Card {\n  constructor(cb) {\n    // remove from a 'state'\n    // object and list under `this`\n    this.address = '';\n    this.web3 = {};\n    this.connext = {};\n    this.tokenAddress = null;\n    this.tokenContract = null;\n    this.channelState = null;\n    this.connextState = null;\n    this.stateUpdateCallback = cb;\n    this.exchangeRate = '0.00';\n    this.hubUrl = null;\n    this.rpcProvider = null;\n  }\n\n  // TODO: take in mnemonic so that users can\n  // generate wallet from another dapplication\n  async init(hubUrl = 'http://localhost:8080', rpcProvider = 'http://localhost:8545') {\n    // Set up wallet\n    const mnemonic = localStorage.getItem('mnemonic');\n    const delegateSigner = await createWallet(mnemonic);\n    const address = await delegateSigner.getAddressString();\n    this.address = address;\n    this.hubUrl = hubUrl;\n    this.rpcProvider = rpcProvider;\n\n    // set up web3 and connext\n    await this.setWeb3(delegateSigner, rpcProvider);\n    await this.setConnext(hubUrl);\n    await this.setTokenContract();\n    await this.authorizeHandler();\n\n    // start polling for state\n    await this.pollConnextState();\n    await this.poller();\n\n    // return address\n    return address;\n  }\n\n  // ************************************************* //\n  //                State setters                      //\n  // ************************************************* //\n  async setWeb3(address, rpcUrl) {\n    const providerOpts = new ProviderOptions(address, rpcUrl).approving();\n    const provider = clientProvider(providerOpts);\n    const customWeb3 = new Web3(provider);\n    this.web3 = customWeb3;\n  }\n\n  async setConnext(hubUrl) {\n    const options = {\n      web3: this.web3,\n      hubUrl,\n      user: this.address,\n    };\n\n    // *** Instantiate the connext client ***\n    const connext = await getConnextClient(options);\n    // console.log(`Successfully set up connext! Connext config:`);\n    // console.log(`  - tokenAddress: ${connext.opts.tokenAddress}`);\n    // console.log(`  - hubAddress: ${connext.opts.hubAddress}`);\n    // console.log(`  - contractAddress: ${connext.opts.contractAddress}`);\n    // console.log(`  - ethNetworkId: ${connext.opts.ethNetworkId}`);\n    this.connext = connext;\n    this.tokenAddress = connext.opts.tokenAddress;\n  }\n\n  async setTokenContract() {\n    try {\n      const tokenContract = new this.web3.eth.Contract(tokenAbi, this.tokenAddress);\n      this.tokenContract = tokenContract;\n    } catch (e) {\n      console.log('Error setting token contract', e); // eslint-disable-line\n    }\n  }\n\n  // ************************************************* //\n  //                    Pollers                        //\n  // ************************************************* //\n  async pollConnextState() {\n    const that = this;\n    // register listeners\n    this.connext.on('onStateChange', state => {\n      if (state.persistent.channel) {\n        const balance = state.persistent.channel.balanceTokenUser;\n        const substr = balance ? getDollarSubstring(balance) : ['0', '00'];\n        let cents = substr[1].substring(0, 2);\n        if (cents.length === 1) cents = `${cents}0`;\n\n        // call cb passed into creator fn with updated amount in card\n        that.stateUpdateCallback(`$${substr[0]}.${cents}`);\n      }\n\n      that.channelState = state.persistent.channel;\n      that.connextState = state;\n      that.exchangeRate = state.runtime.exchangeRate ? state.runtime.exchangeRate.rates.USD : 0;\n    });\n    // start polling\n    await this.connext.start();\n  }\n\n  async poller() {\n    await this.autoDeposit();\n    await this.autoSwap();\n\n    setInterval(async () => {\n      await this.autoDeposit();\n      await this.autoSwap();\n    }, 10000);\n  }\n\n  async autoDeposit() {\n    const { connextState, tokenAddress } = this;\n    const balance = await this.web3.eth.getBalance(this.address);\n    let tokenBalance = '0';\n    try {\n      tokenBalance = await this.tokenContract.methods.balanceOf(this.address).call();\n    } catch (e) {\n      console.warn(\n        `Error fetching token balance, are you sure the token address (addr: ${tokenAddress}) is correct for the selected network (id: ${await this.web3.eth.net.getId()}))? Error: ${\n          e.message\n        }`,\n      );\n    }\n\n    if (balance !== '0' || tokenBalance !== '0') {\n      if (ethers.utils.bigNumberify(balance).lte(DEPOSIT_MINIMUM_WEI)) {\n        // don't autodeposit anything under the threshold\n        return;\n      }\n      // only proceed with deposit request if you can deposit\n      if (!connextState || !connextState.runtime.canDeposit) {\n        // console.log(\"Cannot deposit\");\n        return;\n      }\n\n      const actualDeposit = {\n        amountWei: ethers.utils\n          .bigNumberify(balance)\n          .sub(DEPOSIT_MINIMUM_WEI)\n          .toString(),\n        amountToken: tokenBalance,\n      };\n\n      if (actualDeposit.amountWei === '0' && actualDeposit.amountToken === '0') {\n        // console.log(`Actual deposit is 0, not depositing.`);\n        return;\n      }\n\n      const depositRes = await this.connext.deposit(actualDeposit); // eslint-disable-line\n      // console.log(`Depositing: ${JSON.stringify(actualDeposit, null, 2)}`);\n      // console.log(`Deposit Result: ${JSON.stringify(depositRes, null, 2)}`);\n    }\n  }\n\n  // not totally sure what happens here\n  async autoSwap() {\n    const { channelState, connextState } = this;\n    // const { channelState, connextState } = this.state;\n    if (!connextState || !connextState.runtime.canExchange) {\n      // console.log(\"Cannot exchange\");\n      return;\n    }\n    const weiBalance = ethers.utils.bigNumberify(channelState.balanceWeiUser);\n    const tokenBalance = ethers.utils.bigNumberify(channelState.balanceTokenUser);\n    if (channelState && weiBalance.gt(ethers.utils.bigNumberify('0')) && tokenBalance.lte(HUB_EXCHANGE_CEILING)) {\n      console.log(`Exchanging ${channelState.balanceWeiUser} wei`); // eslint-disable-line\n      await this.connext.exchange(channelState.balanceWeiUser, 'wei');\n    }\n  }\n\n  // ************************************************* //\n  //                    Handlers                       //\n  // ************************************************* //\n  async authorizeHandler() {\n    const { web3 } = this;\n    const challengeRes = await axios.post(`${this.hubUrl}/auth/challenge`, {}, opts);\n\n    const data = `${HASH_PREAMBLE} ${web3.utils.sha3(challengeRes.data.nonce)} ${web3.utils.sha3('localhost')}`;\n    const hash = web3.utils.sha3(data);\n    const signature = await web3.eth.personal.sign(hash, this.address, null);\n\n    try {\n      const authRes = await axios.post(\n        `${this.hubUrl}/auth/response`,\n        {\n          nonce: challengeRes.data.nonce,\n          address: this.address,\n          origin: 'localhost',\n          signature,\n        },\n        opts,\n      );\n      const { token } = authRes.data;\n      document.cookie = `hub.sid=${token}`;\n      // console.log(`hub authentication cookie set: ${token}`);\n      const res = await axios.get(`${this.hubUrl}/auth/status`, opts);\n      // console.log('res', res.data);\n      // console.log(`Auth status: ${JSON.stringify(res.data)}`);\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  // ************************************************* //\n  //                  Send Funds                       //\n  // ************************************************* //\n  async generateRedeemableLink(value) {\n    const { connext } = this;\n    // const { paymentVal } = this.state;\n\n    // generate secret, set type, and set\n    // recipient to empty address\n    const payment = {\n      meta: { purchaseId: 'payment' },\n      payments: [{\n        type: 'PT_LINK',\n        recipient: emptyAddress,\n        secret: connext.generateSecret(),\n        amount: {\n          amountToken: (value * Math.pow(10, 18)).toString(),\n          amountWei: '0',\n        },\n      }]\n    };\n\n    // refactored to avoid race conditions around\n    // setting state\n    return this.paymentHandler(payment);\n  }\n\n  async generatePayment(value, recipientAddress) {\n    const { connext } = this;\n    // const { paymentVal } = this.state;\n\n    // generate secret, set type, and set\n    const payment = {\n      meta: { purchaseId: 'payment' },\n      payments: [{\n        type: 'PT_CHANNEL',\n        recipient: recipientAddress,\n        secret: connext.generateSecret(),\n        amount: {\n          amountToken: (value * Math.pow(10, 18)).toString(),\n          amountWei: '0',\n        },\n      }],\n    };\n\n    // refactored to avoid race conditions around\n    // setting state\n    await this.paymentHandler(payment);\n  }\n\n  async paymentHandler(payment) {\n    const { connext, web3, channelState } = this;\n    // const { connext, web3, channelState } = this.props;\n\n    console.log(`Submitting payment: ${JSON.stringify(payment, null, 2)}`);\n    let balanceError, addressError;\n\n    // validate that the token amount is within bounds\n    const paymentAmount = convertPayment('bn', payment.payments[0].amount);\n    if (paymentAmount.amountToken.gt(new BN(channelState.balanceTokenUser))) {\n      console.log('Insufficient balance in channel')\n      // balanceError = 'Insufficient balance in channel';\n    }\n\n    if (paymentAmount.amountToken.isZero()) {\n      console.log('Please enter a payment amount above 0')\n      // balanceError = 'Please enter a payment amount above 0';\n    }\n\n    // validate recipient is valid address OR the empty address\n    // TODO: handle in other functions that structure payment object\n    const { recipient } = payment.payments[0];\n    if (!web3.utils.isAddress(recipient) && recipient !== emptyAddress) {\n      addressError = 'Please choose a valid address';\n    }\n\n    // return if either errors exist\n    if (balanceError || addressError) {\n      // TODO: throw an error\n      return false;\n    }\n\n    // otherwise make payment\n    try {\n      let paymentRes = await connext.buy(payment);\n      console.log(`Payment result: ${JSON.stringify(paymentRes, null, 2)}`);\n      if (payment.payments[0].type === 'PT_LINK') {\n        return payment.payments[0].secret;\n      }\n      return true;\n    } catch (e) {\n      // TODO: throw error here\n      // console.log('SEND ERROR, SETTING');\n      // this.setState({ sendError: true, showReceipt: true });\n    }\n  }\n\n  async redeemPayment(secret) {\n    // const { isConfirm, purchaseId, retryCount } = this.state;\n    const { connext, channelState, connextState } = this;\n    if (!connext || !channelState || !connextState) {\n      console.log('Connext or channel object not detected');\n      return;\n    }\n\n    if (!secret) {\n      console.log('No secret detected, cannot redeem payment.');\n      return;\n    }\n\n    // if (isConfirm) {\n    //   console.log('User is creator of linked payment, not automatically redeeming.');\n    //   return;\n    // }\n\n    // user is not payor, can redeem payment\n    try {\n      const updated = await connext.redeem(secret);\n      console.log('redeemed successs?', updated);\n      // if (!purchaseId && retryCount < 5) {\n      //   console.log('Redeeming linked payment with secret', secret)\n      //   if (updated.purchaseId == null) {\n      //     this.setState({ retryCount: retryCount + 1})\n      //   }\n      //   this.setState({ purchaseId: updated.purchaseId, amount: updated.amount, showReceipt: true });\n      // }\n      // if (retryCount >= 5) {\n      //   this.setState({ purchaseId: 'failed', sendError: true, showReceipt: true });\n      // }\n    } catch (e) {\n      // TODO: throw error\n      // if (e.message.indexOf('Payment has been redeemed') !== -1) {\n      //   this.setState({ retryCount: 5, previouslyRedeemed: true })\n      //   return\n      // }\n      // this.setState({ retryCount: retryCount + 1 });\n      // console.log('retryCount', retryCount + 1)\n    }\n  }\n}\n\nexport default Card;\n"],"file":"index.js"}