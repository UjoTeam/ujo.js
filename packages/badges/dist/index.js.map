{"version":3,"sources":["../src/index.js"],"names":["Badges","web3","getExchangeRate","getBlockNumber","networkId","config","getNetwork","badgesProxyAddress","UjoPatronageBadges","badgeContract","eth","Contract","UjoPatronageBadgesFunctions","abi","storageProvider","getTransactionReceipt","tokenIds","endBlock","startBlock","blocksPerWindow","windows","Array","Math","ceil","fill","Promise","all","map","_","idx","fromBlock","toBlock","options","filter","tokenId","toString","getPastEvents","Error","error","findEventData","encodedTxData","eventData","badge","fetchMetadataByQueryParameter","data","getBadges","badges","ethereumAddress","methods","getAllTokens","call","uniqueIdentifier","txHash","txReceipt","decodeLog","indexed","name","type","logs","topics","nftcid","timeMinted","formattedTimeMinted","moment","unix","utc","format","badgeBuyerAddress","beneficiaries","splits","patronageBadgePrice","exchangeRate","amountInWei","mint","estimateGas","from","value","to","address","gasRequired","gas","send"],"mappings":"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","sourcesContent":["import moment from 'moment';\nimport { getContractAddress, dollarToWei, boostGas } from '../../utils/dist';\nimport { UjoPatronageBadges, UjoPatronageBadgesFunctions } from '../../contracts-badges';\n\nimport { decodeTxData, determineStartBlock } from './helpers';\n\nclass Badges {\n  constructor() {\n    this.web3 = {};\n    this.getExchangeRate = async () => {};\n    this.getBlockNumber = async () => {};\n    this.networkId = '';\n  }\n\n  /**\n   * the init method provides an API for interacting with ujo patronage badges\n   * @param {Object} ujoConfig - the config object returned by init @see [link]\n   * @returns {Object} - an interface for interacting with badges\n   */\n  async init(config) {\n    this.web3 = config.web3;\n    this.networkId = await config.getNetwork();\n    this.badgesProxyAddress = getContractAddress(UjoPatronageBadges, this.networkId);\n    this.badgeContract = new this.web3.eth.Contract(UjoPatronageBadgesFunctions.abi, this.badgesProxyAddress);\n\n    // Sample storage provider setup\n    this.storageProvider = config.storageProvider;\n\n    // Cached functions that need to be executed at runtime\n    this.getBlockNumber = config.getBlockNumber;\n    this.getExchangeRate = config.getExchangeRate;\n    this.getTransactionReceipt = config.getTransactionReceipt;\n  }\n\n  /**\n   * findEventData\n   * @param {string} tokenIds - indexed parameter to filter event logs on\n   * @param {string} blocksPerWindow - the number of blocks you want to scan per window\n   * @param {string} startBlock - where in the blockchain we start scanning from\n   * @param {string} endBlock - w\n   * @returns {Object} - an interface for interacting with badges\n   */\n  async findEventData(tokenIds) {\n    if (this.badgeContract) {\n      // TODO - take these as variables\n      const endBlock = await this.getBlockNumber();\n      const startBlock = determineStartBlock(this.networkId);\n      const blocksPerWindow = 5000;\n\n      // create an array to store parallelized calls to ethereum block chunks\n      const windows = new Array(Math.ceil((endBlock - startBlock) / blocksPerWindow)).fill();\n\n      // all of these calls get invoked at one after the other, but the entire promise\n      // will not resolve until all have completed\n      return Promise.all(\n        windows.map((_, idx) => {\n          // TODO - Explain why the from and to blocks are different if you're at the first index\n          const fromBlock = idx === 0 ? startBlock : startBlock + blocksPerWindow * idx + 1;\n          const toBlock = idx === 0 ? startBlock + blocksPerWindow : startBlock + blocksPerWindow * (idx + 1);\n          const options = {\n            filter: { tokenId: tokenIds }, // tokenId is an indexed parameter in the smart contract\n            fromBlock: fromBlock.toString(),\n            toBlock: toBlock.toString(),\n          };\n          // issue the event logs request to ethereum\n          return this.badgeContract.getPastEvents('LogBadgeMinted', options);\n        }),\n      );\n    }\n    return new Error({\n      error: 'Attempted to get badge data with no smart contract',\n    });\n  }\n\n  async getBadges(tokenIds) {\n    const encodedTxData = await this.findEventData(tokenIds);\n\n    // reformats tx data to be useful for clients and/or storage layer\n    const eventData = decodeTxData(encodedTxData);\n    return eventData;\n  }\n\n  /* this function takes a badge in the format given back by getBadges\n  [\n    <String> unique identifier (in our case cid)\n    <String> time minted\n    <String> txHash\n  ]\n\n  takes the unique identifier (badge[0] is cid), and gets the badge metadata from the storage provider\n  reformats the badgemetadata for the api spec\n  */\n  async getBadgeMetadata(badge) {\n    const { data } = await this.storageProvider.fetchMetadataByQueryParameter(badge[0]);\n    // reformat data here\n    return data;\n  }\n\n  /**\n   * getAllBadges is a getter method for every single badge in the proxy contract\n   * @returns {Promise<Object[], Error>} an array of badges.\n   * See {@link getBadge} for what each badge looks like in the returned array\n   */\n  async getAllBadges() {\n    try {\n      // get all the badge data\n      // the empty array means all badges (not any specific tokenIds)\n      const badges = await this.getBadges(null, this.networkId);\n      // add this snippet to unfurl music group data in badges and reformat badge data\n      // try {\n      //   const badgesWithMetadata = await Promise.all(badges.map(getBadgeMetadata));\n      // } catch (error) {\n      //   return new Error({ error: 'most likely hit an endpoint rate limit' });\n      // }\n      return badges;\n    } catch (error) {\n      return new Error({ error: 'Error fetching badges' });\n    }\n  }\n\n  /**\n   * getBadgesOwnedByAddress is a getter method for every single badge owned by ethereum address\n   * @param {string} ethereumAddress - the ethereum address owner of returned badges\n   * @returns {Promise<Object[], Error>} an array of badges.\n   * See {@link getBadge} for what each badge looks like in the returned array\n   */\n  async getBadgesOwnedByAddress(ethereumAddress) {\n    try {\n      // fetch the token IDs owned by ethereum address\n      const tokenIds = await this.badgeContract.methods.getAllTokens(ethereumAddress).call();\n      const badges = await this.getBadges(tokenIds);\n      /* --- add this snippet to unfurl music group metadata within the badges and reformat the badges --- */\n      // try {\n      //   const badgesWithMetadata = await Promise.all(badges.map(getBadgeMetadata));\n      // } catch (error) {\n      //   return new Error({ error: 'most likely hit an endpoint rate limit' });\n      // }\n\n      return badges;\n    } catch (error) {\n      return new Error({ error: 'Error fetching badges' });\n    }\n  }\n\n  /**\n   * getBadgesMintedFor is a getter method for every single badge representing a\n   * unique id (in our case music group IPFS cid) by ethereum address\n   * @param {string} uniqueId - the unique id that the badge represents (in our case it's an IPFS cid)\n   * @returns {Promise<Object[], Error>} an array of badges. See {@link getBadge} for what each badge looks like in the returned array\n   */\n  async getBadgesMintedFor(uniqueIdentifier) {\n    // get all the badge data. null is passed because there are no filters\n    const badges = await this.getBadges(null);\n    // do we want to return any other data with these badges?\n    return badges.filter(badge => badge[0] === uniqueIdentifier);\n    // add this snippet to unfurl music group information in badge and reformat badge data\n    // .map(getBadgeMetadata)\n  }\n\n  /**\n   * getBadge is a getter method for a single badge\n   * meant to get more information about the badges\n   * returns transaction receipt along with formatted badge data\n   * returns null if transaction has not been mined to chain yet\n   * @param {string} txHash - the transaction hash of the badge minting\n   * @returns {Promise<Object, Error>} a single badge object\n   * @todo decide on this object ^^\n   */\n  async getBadge(txHash) {\n    let txReceipt;\n    try {\n      txReceipt = await this.getTransactionReceipt(txHash);\n    } catch (error) {\n      return new Error({ error: 'Error getting transaction receipt' });\n    }\n    if (txReceipt) {\n      try {\n        // decode the logs from the transaction receipt based on event log signature\n        const { nftcid, timeMinted } = this.web3.eth.abi.decodeLog(\n          [\n            { indexed: true, name: 'tokenId', type: 'uint256' },\n            { indexed: false, name: 'nftcid', type: 'string' },\n            { indexed: false, name: 'timeMinted', type: 'uint256' },\n            { indexed: false, name: 'buyer', type: 'address' },\n            { indexed: false, name: 'issuer', type: 'address' },\n          ],\n          txReceipt.logs[0].data,\n          txReceipt.logs[0].topics,\n        );\n        const formattedTimeMinted = moment\n          .unix(timeMinted)\n          .utc()\n          .format('MMMM Do, YYYY');\n\n        // this is the format of how badge data gets returned in the event log\n        const data = [nftcid, formattedTimeMinted, txHash];\n        // add this snippet to unfurl music group information in badge and reformat badge data\n        // const badgeWithMetadata = getBadgeMetadata(data)\n\n        // add the formatted badge data along with the rest of the tx receipt\n        // see https://web3js.readthedocs.io/en/1.0/web3-eth.html#gettransactionreceipt\n        return { ...txReceipt, data };\n      } catch (error) {\n        return new Error({ error: 'Error decoding txReceipt logs' });\n      }\n    }\n    // is this right?\n    return null;\n  }\n\n  /**\n   * mints a new badge\n   * @param {string} badgeBuyerAddress - the eth address of the owner of the new badge\n   * @param {string} uniqueIdentifier - the resource that the newly minted badge represents (cid in our case)\n   * @param {string[]} beneficiaries - an array of ethereum addresses who will receive the money paid for the badge\n   * @param {number[]} splits - an array of integers that represent the amount paid to each beneficiary (out of 100). Must be in the same order as the beneficiary\n   * @param {number} patronageBadgePrice - the amount the badge costs in USD\n   */\n  async buyBadge(badgeBuyerAddress, uniqueIdentifier, beneficiaries, splits, patronageBadgePrice) {\n    const exchangeRate = await this.getExchangeRate();\n    const amountInWei = dollarToWei(patronageBadgePrice, exchangeRate);\n    const gasRequired = await this.badgeContract.methods\n      .mint(badgeBuyerAddress, uniqueIdentifier, beneficiaries, splits, patronageBadgePrice)\n      .estimateGas({\n        from: badgeBuyerAddress,\n        value: amountInWei,\n        to: this.badgeContract.address,\n      });\n\n    const gas = boostGas(gasRequired);\n    return this.badgeContract.methods\n      .mint(badgeBuyerAddress, uniqueIdentifier, beneficiaries, splits, patronageBadgePrice)\n      .send({\n        from: badgeBuyerAddress,\n        value: amountInWei,\n        to: this.badgeContract.address,\n        gas,\n      });\n  }\n}\n\nexport default Badges;\n"],"file":"index.js"}